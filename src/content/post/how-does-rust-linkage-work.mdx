---
title: 
description:
publishDate: 
tags: []
draft: true
---
Goals
- Basics of Linking in Unix systems
- Ld basics (mention mold)
- Rust compilation viz, linking static vs dynamic
- Demo
- Dive deeper
- Part II follow up for Windows

# Understanding Linking

"Programmers tend to build their programs on top of libraries of reusable code — for example, libc, which we talked about earlier. When turning your source code into an executable binary, a program called a linker resolves all these references by finding the library code and copying it into the binary. This process is called _static linking_, which means external code is included directly in the file that’s distributed."

A simple analogy for a Linker:
> Executable Linkers are basically just home theater setups - Chris Kanich

What are Symbols?

Symbols are how we go from variable names -> memory addresses in machine instructions. 

Compiler -> Symbols -> Linker -> Symbol Resolution 

In compiled language like C, C++, or Rust, a build consists of two phases. In the first phase, a compiler compiles source files into object files (`.o` files). In the second phase, a linker takes all object files and combines them into a single executable or shared library file.

## Linking in Linux systems

Let's setup a simple rust project in a Ubuntu Virtual Machine, and try to understand linking with it. I'm using [orbstack](https://docs.orbstack.dev/architecture#:~:text=OrbStack%20uses%20a%20lightweight%20Linux,integration%20with%20macOS%2C%20and%20more.) to create a "machine" on macOS which work like traditional vms, but shares the same kernel. 

After setting up rust in the vm using [rustup](https://rustup.rs), we use cargo to create a new rust project.

```bash
$ cargo new learning-linkers
```

Let's try to build it.

```shell
$ cd learning-linkers && cargo build
Compiling learning-linkers v0.1.0 (/Users/shrirambalaji/Repositories/learning-linkers)
error: linker `cc` not found
  |
  = note: No such file or directory (os error 2)
```

Hmm, an error. We run into a ```linker `cc` not found error``` because the rust installer assumes that a C linker is already installed, instead of checking for the necessary compiler toolchain. 

On linux machines, the de-facto toolchain is `gcc`(GNU Compiler Collection) which seems to be missing. The `build-essential` meta package has `gcc` and a couple other packages. Let's install that!

```shell
$ sudo apt install build-essential
```

We can also choose a different linker like [`lld`](https://lld.llvm.org)which is LLVM's linker or [mold](https://github.com/rui314/mold). [LLVM](https://llvm.org)is another compiler toolchain like gcc, but aims to be modular. Mold is a more recent alternative and is several times quicker based on their benchmarks.

### Rust Compilation and the  `.o` object file

When you run `cargo build` in a Rust project, it doesn't output a single `.o` object file unlike C. This behavior stems from differences in the compilation models and build systems of Rust and C. There are a couple of reasons for it:

-  `rustc` (invoked internally by `cargo`) compiles rust source code into an executable or a library (`.rlib`), rather than separately compiling to an object file and then linking them ie. it tries to do both the phases (compilation and linking) we discussed earlier in one step.
- `rustc` views a crate as the basic unit of compilation, not  files. hence, it typically compiles an entire crate in one go.

But that doesn't mean that there are no `.o` files, they are present in `/target/debug/incremental/*` directories. If you guessed it already, yes - rust supports incremental compilation ie. it compiles parts of a crate / project that have changed since the previous build. But these are typically managed by `rustc` and `cargo` internally.

Let's say we want to emit just an`object` file similar to what happens when we compile a `C` program.

```bash
$ rustc --emit=obj main.rs
```

This tells `rustc` to emit an object file (`main.o`) from the source file `main.rs`. The default `main.rs` source code just has a `main` function which prints out "Hello, World!"

```rust
fn main() {
    println!("Hello, world!");
}
```

But, there's a catch - the raw .o file doesn't have enough information that `rustc` needs to generate stubs / shims and invoke the linker. Moreover, the arguments we pass onto the linkers are crate-specific, and that information is missing in the object files. 

So essentially, the generated `.o` object files are not  useful to us.


References:
https://blog.mozilla.org/nnethercote/2019/10/10/visualizing-rust-compilation/