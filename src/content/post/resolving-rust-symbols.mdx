---
title: Resolving Rust Symbols
description: This article is about my understanding of Rust linking, detailing learnings along the way about Linking in Unix systems, how Rust linkage differs from C, trying different linkers like mold, lld and understanding what they offer.
publishDate: May 15, 2024
tags:
  - rust
  - linking
  - systems
draft: true
---

import { Picture, Image } from "astro:assets";
import ThemedImage from "@/components/ThemedImage";
import LightImage from "./attachments/compiler-build-symbols-resolve-linker.svg";
import DarkImage from "./attachments/compiler-build-symbols-resolve-linker-dark.svg";

> Programmers tend to build their programs on top of libraries of reusable code. When turning your source code into an executable binary, a program called a linker resolves all these references by finding the library code and copying it into the binary. This process is called _static linking_, which means external code is included directly in the file that’s distributed. - Chris Kanich

Linking is the process of combining object files into an executable or shared library. It's like putting together puzzle pieces to create a working program. Symbol resolution is a key part of linking, where variable and function names are matched with their corresponding memory addresses. Symbols are important for referencing code within a program.

<ThemedImage
	alt="Compiler Build Symbols Resolved by Linker"
	src={"/src/content/post/attachments/compiler-build-symbols-resolve-linker.svg"}
	darkSrc={"/src/content/post/attachments/compiler-build-symbols-resolve-linker-dark.svg"}
></ThemedImage>

In compiled languages like C, C++, or Rust, a build step consists of two phases. In the first phase, a compiler compiles source files into object files (`.o` files). In the second phase, a linker takes all object files and combines them into a single executable or shared library file. Let's try to understand linking, but in the context of Rust.

## What does a Linker do?

- Resolves symbols in object files
- Combines object files into a single executable or shared library
- Resolves dependencies between object files
- Generates a symbol table for the final executable

### Linking in Unix-like Systems

In Unix-like systems, the linker is typically `ld` (linker and loader). The linker is responsible for resolving symbols in object files and generating the final executable or shared library.

To understand this from a rust perspective, let's setup a simple rust project. I'll be switching back and forth between Linux and macOS, to compare and contrast things.

 For the Linux VM, I'm using [orbstack](https://docs.orbstack.dev/architecture#:~:text=OrbStack%20uses%20a%20lightweight%20Linux,integration%20with%20macOS%2C%20and%20more.) to create a "machine" on macOS which work like traditional vms, but shares the same kernel.

After setting up rust in the vm using [rustup](https://rustup.rs), we use cargo to create a new rust project.

```bash
$ cargo new learning-linkers
```

Let's try to build it.

```shell
$ cd learning-linkers && cargo build
Compiling learning-linkers v0.1.0 (/Users/shrirambalaji/Repositories/learning-linkers)
error: linker `cc` not found
  |
  = note: No such file or directory (os error 2)
```

Hmm, an error. We run into a ``linker `cc` not found error`` because the rust installer assumes that a C linker is already installed, instead of checking for the necessary compiler toolchain.

On linux machines, the de-facto toolchain is `gcc`(GNU Compiler Collection) which seems to be missing. The default linker `ld` is part of `gcc` and hence needs to be installed (the first time). The `build-essential` meta package has `gcc` and a couple other packages:

```shell
$ sudo apt install build-essential
```

We can also choose a different linker like [`lld`](https://lld.llvm.org)which is LLVM's linker or [mold](https://github.com/rui314/mold). [LLVM](https://llvm.org)is another compiler toolchain like gcc, but aims to be modular. Mold is a more recent alternative and is several times quicker based on their benchmarks.

We'll come across LLVM again, because `rustc` relies heavily on LLVM during different stages of compilation.

## Rust Compilation Pipeline

<ThemedImage
	alt="Rust Compilation Pipeline"
	src={"/src/content/post/attachments/rust-compilation.svg"}
	darkSrc={"/src/content/post/attachments/rust-compilation-dark.svg"}
></ThemedImage>

To understand linking, it's crucial to understand the rust compilation pipeline which involves a series of steps, from source code -> executable.

### Lexing and parsing

<ThemedImage
	alt="Rust Compilation - Lexing & Parsing Phase"
	src={"/src/content/post/attachments/rust-compilation-lexing-parsing.svg"}
	darkSrc={"/src/content/post/attachments/rust-compilation-lexing-parsing-dark.svg"}
  borderDashed
></ThemedImage>

The source code is analyzed by a [lexer (`rustc_lexer`)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lexer/index.html) and converted into a stream of [tokens](). Then, the [parser (`rustc_parse`)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_parse/index.html) takes in the stream of tokens and converts it into an [abstract syntax tree](https://en.wikipedia.org/wiki/Abstract_syntax_tree) (AST).

### HIR & MIR

The AST from the previous step is converted into a HIR (High-level Intermediate Representation), which is a friendlier representation to work with. During this step the compiler does the following:

- Performs macro expansion
- Desugars syntactic sugar
- [Type inference](https://rustc-dev-guide.rust-lang.org/type-inference.html) ie. automatically deducing the types of variables and expressions
- [Trait Solving](https://rustc-dev-guide.rust-lang.org/traits/resolution.html) → Finding the correct implementation of a trait for a type
- [Type Checking](https://rustc-dev-guide.rust-lang.org/type-checking.html) → Converting HIR types (hir::Ty) to Rustc's internal types (ty::Ty)

The process of converting AST to HIR is called **lowering**. Then, the HIR is further lowered into an MIR (Middle-level Intermediate Representation), which is a more low-level representation. During this transformation, the compiler performs optimizations and does Monomorphization.

Monomorphization is the fancy term for generating specialized code for each type that a generic function is called with. This helps reduce the overhead of generics in Rust, and that's why Rust is often referred to as a "zero-cost abstractions" language. But hey, let's not forget, there's no such thing as a **free lunch**. The cost is _probably_ paid during compilation.

### Code Generation & Building the executable

<ThemedImage
	alt="Rust Compilation - Building the executable"
	src={"/src/content/post/attachments/rust-compilation-building-executable.svg"}
	darkSrc={"/src/content/post/attachments/rust-compilation-building-executable-dark.svg"}
  borderDashed
></ThemedImage>


The MIR is then converted into LLVM IR (Intermediate Representation)is used by the LLVM toolchain. We will come back to LLVM IR, because it's pretty interesting.

The LLVM-IR is passed to LLVM, which does a bunch of fancy optimizations on it, spitting out machine code that's basically assembly code with some extra low-level types and annotations (like an ELF object or WASM). Then, all the different libraries and binaries are linked together to create the final binary.

whew, that was a lot of information. Let's get back to linking.

## Building the output - The `.o` object file

It's a systems language, so obviously our expectation is to be similar to C - right? Just let me compile, and give me an object file that I can link to later? That's called [dynamic linking](https://en.wikipedia.org/wiki/Dynamic_linker) and that's the default of how things work with C, C++.

Rust prefers the opposite - called [static linking](https://en.wikipedia.org/wiki/Static_library) wherein it will link in all Rust and native dependencies, producing a single distributable binary as described above.

> A [_crate_](https://doc.rust-lang.org/reference/crates-and-source-files.html) is a unit of compilation and linking, as well as versioning, distribution, and runtime loading. A crate contains a *tree* of nested [module](https://doc.rust-lang.org/reference/items/modules.html) scopes.

In Rust,the default crate type is `bin` for binaries and `lib` for libraries. The `bin` crate type is used for creating executables, and the `lib` crate type is used for creating libraries. The `crate-type` attribute in the `Cargo.toml` file can be used to specify the crate type or it can be specified using the `--crate-type` flag.


I mentioned that rust prefers static linking, but that doesn't mean that it doesn't produce `.o` files. It does, but it's not as straightforward as C. Here's why:
- `rustc` (invoked internally by `cargo`) compiles rust source code into an executable or a library (`.rlib`), rather than separately compiling to an object file and then linking them ie. it tries to do both the phases (compilation and linking) we discussed earlier in one step.
- `rustc` views a crate as the basic unit of compilation, not files. hence, it typically compiles an entire crate at once.

Also, even in the case of the `bin` crate the `.o` files are present in the `/target/debug/incremental/*` directories. If you guessed it already, these are output files from rust's incremental compilation ie. it compiles parts of a crate / project that have changed since the previous build. However, these are typically managed by `rustc` and `cargo` internally.

## What's inside the `.o` file?

> For some reason, when I use the Linux VM to visualize the symbol tables, the addresses are always `0000000000000000`. I'm not sure why this is the case, but I'll try to figure it out. I'm running the same commands on macOS and Linux, but the output is different. I'll update this section once I figure it out.

We can use the `--emit=obj` file to instruct `rustc` to emit the object files. Yay, easy peasy right? No, it gets a bit tricky after that.

 Let's understand this with an example, we have two files `foo.rs` and `bar.rs` which we will try to compile and link manually.

```rs
// foo.rs
#![no_main] // [!code highlight]

#[no_mangle] // [!code highlight]
pub static mut Global: i32 = 5;


#[no_mangle]
pub fn foo() {
  unsafe { // [!code highlight]
    Global = 10; // [!code highlight]
  } // [!code highlight]
}
```

The `#![no_main]` attribute is straightforward, it tells the compiler that there is no `main` function, and effectively not to throw a compiler error when it doesn't find one. 


The [`unsafe`](https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html) block tells the compiler that whatever is inside it puts the onus on the programmer to ensure memory safety. In this case, we are modifying a global variable from two different functions, which is _not safe_ in Rust. 

### The `#[no_mangle]` attribute

When Rust code is compiled, identifiers are “mangled” ie. transformed into a different name to include additional information. 

For example, with mangling enabled (ie. by default) the above foo `Global` variable gets mangled to `__ZN11foo6Global17ha2a12041c4e557c5E`. This is done to avoid naming conflicts when linking with other libraries, however we disable it with `#[no_mangle]` so that the symbol name is preserved, and can be easily linked with other languages by name.

Here's, `bar.rs`:

```rs
// bar.rs
extern "C" { // [!code highlight]
  static mut Global: i32;
  fn foo();
}

#[no_mangle]
pub static mut Global: i32 = 5;

#[no_mangle]
pub extern "C" fn bar() {
  let mut a = 100;
  unsafe {
    foo();
    a = Global;
  }
  a += 200;
}


fn main() {
  unsafe {
    foo();
    bar();
  }
}
```

The `extern "C"` block tells the compiler that the function or variable is defined in another language. You may wonder why it's `extern C`, and that's because this doesn't mean we are inter-operating with C, but rather the ABI (Application Binary Interface) that the function or variable uses. In this case, it's the C ABI.

Now, let's compile these files to object files. (This, isn't how you would typically compile a rust program, but we are doing this to understand the linking process). 

```bash
$ rustc --emit=obj -o foo.o foo.rs
$ rustc --emit=obj -o bar.o bar.rs
```

Let's say we want to take a peak into the object file. We can use the `nm` command to list the symbols in the object file. The `nm` command is a Unix utility that displays the symbol table of an object file. [Symbol table](https://en.wikipedia.org/wiki/Symbol_table#:~:text=In%20computer%20science%2C%20a%20symbol,or%20appearance%20in%20the%20source.) is a data structure that contains a list of symbols and their addresses. 

```bash
$ nm foo.o
0000000000000010 D _Global
0000000000000000 T _foo
0000000000000000 t ltmp0
0000000000000010 d ltmp1
0000000000000018 s ltmp2
```

The output of `nm` is in the following format:
- `D` - Global Data section symbol
- `T` - Global Text symbol
- `d` - Local symbol in the data section
- `s` - Unitialized Local symbol for small objects

If you haven't noticed, the lowercase denotes local symbols, and uppercase denotes global symbols. The `ltmp` symbols are temporary symbols generated by the compiler during the compilation process.

Okay, let's look at the symbol table of `bar.o`:

```bash
$ nm bar.o
               U __ZN4core9panicking5panic17h57fd475c037a9df3E  # [!code highlight]
0000000000000000 T _bar
                 U _foo # [!code highlight]
000000000000006c T _foo_bar
00000000000000a0 s _str.0
00000000000000c0 s l___unnamed_1
0000000000000090 s l___unnamed_2
0000000000000000 t ltmp0
0000000000000090 s ltmp1
00000000000000c0 s ltmp2
00000000000000d8 s ltmp3
0000000000000118 s ltmp4
```

wherein `U` denotes an Undefined symbol.

On the highlighted line above, there's an _undefined_ symbol reference to the panic function from the `core::panicking` crate, which will be resolved when linking (if we link it correctly). 

I think this is because rust programs use the default `panic_handler` when using the `std` library, and if we use the `no_std` attribute, we have to implement our own `panic_handler`. This is typical in embedded systems, or when building a new operating system where the standard rust library cannot be used.

Similarly, the `foo` function on line 3, is also _undefined_ in the `bar.o` file, and will be resolved during the linking phase. Let's now try to manually link these object files.

```bash
$ ld -o main foo.o bar.o
```

Oops, a linker error:

```bash
$ ld -o main src/foo.o src/bar.o
Undefined symbols for architecture arm64:
  "__ZN4core9panicking5panic17h57fd475c037a9df3E", referenced from:
      _bar in bar.o
  "_main", referenced from:
      <initial-undefines>
  "dyld_stub_binder", referenced from:
      <initial-undefines>
ld: symbol(s) not found for architecture arm64
```

The error message is pretty clear - the `core::panicking::panic` symbol is undefined. We need to link the `core` crate to resolve this error. But, we can't just link the `core` crate, because it's not a `.o` file, but a `.rlib` file. As far as I know, there's no way to link a `.rlib` file directly with `ld` nor is it straightforward to link it with `rustc`.

## `staticlib` to the rescue

> `--crate-type=staticlib, #![crate_type = "staticlib"]` -  The purpose of this output type is to create a static library containing all of the local crate's code along with all upstream dependencies - [Linkage](https://doc.rust-lang.org/reference/linkage.html)

Instead of us trying to link the `core` crate and bring in std dependencies, we can create a static library from the `foo.rs` and `bar.rs` files, and then link them together. Let's do that.

```bash
# create a directory to store the output
$ mkdir -p target/out
$ rustc --crate-type=staticlib -o target/out/libfoo.a foo.rs
$ rustc --crate-type=staticlib -o target/out/libbar.a bar.rs
```

Note that the output is a `.a` file, which is a static library / archive in *nix systems. It actually does have the `.o` files we saw above, and we can take a quick peek. We use the `ar` command to list the contents of the archive.

```bash
$ ar -t target/out/libfoo.a | grep foo
foo.foo.730f9a7e513a85b2-cgu.0.rcgu.o
foo.10ftosr6tvdwscdu.rcgu.o
```

Interesting, the `.a` file contains the `.o` files we saw earlier, but with a different name, specifically with `*.rcgu.o` suffix. The `rcgu` stands for "Rust Codegen Unit" and is a unit of code that the compiler generates during [Code Generation](#code-generation--building-the-executable) phase.

Let's extract the `.o` file and look at the symbol table, again.

```bash
$ ar -x target/out/libfoo.a foo.foo.730f9a7e513a85b2-cgu.0.rcgu.o
$ nm foo.foo.730f9a7e513a85b2-cgu.0.rcgu.o 
0000000000000010 D _Global
0000000000000000 T _foo
0000000000000000 t ltmp0
0000000000000010 d ltmp1
0000000000000018 s ltmp2
```

Ah, yes the same symbols we saw earlier. 

## Adding a build script

Cargo lets us run a build script before building the project. The build script is a Rust file called `build.rs` that goes in the project's root.

```rust
// build.rs
fn main() {
    println!("cargo:rustc-link-search=native=target/out");
    println!("cargo:rustc-link-lib=static=foo");
    println!("cargo:rustc-link-lib=static=bar");
}
```

The `cargo:rustc-link-search=native=target/out` tells the compiler to search for the static libraries in the `target/out` directory. The `cargo:rustc-link-lib=static=foo` and `cargo:rustc-link-lib=static=bar` tells the compiler to link the `foo` and `bar` static libraries.

Now, we can compile the project with `cargo build` and it should link the static libraries. Actually, we can even add the previous `rustc` commands to run in the build script so that we can just run `cargo build` to compile the project.

```rust
use std::process::Command;

fn main() {
    // rerun if foo.rs or bar.rs changes
    println!("cargo:rerun-if-changed=src/foo.rs");
    println!("cargo:rerun-if-changed=src/bar.rs");

    // creates the output directory in target/out
    std::fs::create_dir_all("target/out").unwrap();

    // Compile foo.rs and bar.rs into a static library
    Command::new("rustc")
        .args(&[
            "--crate-type=staticlib",
            "src/foo.rs",
            "-o",
            "target/out/libfoo.a",
        ])
        .status()
        .unwrap();

    Command::new("rustc")
        .args(&[
            "--crate-type=staticlib",
            "src/bar.rs",
            "-o",
            "target/out/libbar.a",
        ])
        .status()
        .unwrap();

    // Tell cargo to tell rustc to link the system foo library
    println!("cargo:rustc-link-search=native=target/out");
    println!("cargo:rustc-link-lib=static=foo");
    println!("cargo:rustc-link-lib=static=bar");
}
```

## Validating if everything works

Until now, we don't have a `main.rs` file, so let's create one that calls the `foo` and `bar` functions.

```rust
// main.rs
extern "C" {
    fn foo();
    fn bar();
    static mut Global: i32;
}

fn main() {
    unsafe {
        foo();
        bar();
        println!("Global: {}", Global);
    }
}
```

### Linker errors on macOS

On macOS, we run into a linker error when trying to compile the project. The error is `ld: library not found for -lSystem`. This is because the linker is trying to link the `System` library, which is a system library on macOS. We can fix this by adding the `macos` linker flag to the `cargo:rustc-link-lib` directive in the build script.

I tried a bunch of different options, including adding a compiler flag `-L` and even went to extent of using `lld` directly instead of the default linker. 

```rust
// build.rs
fn main() {
    println!("cargo:rustc-link-search=native=target/out");
    println!("cargo:rustc-link-lib=static=foo");
    println!("cargo:rustc-link-lib=static=bar");

    // Add the macos linker flag
    println!("cargo:rustc-link-lib=framework=System");
}
```

Now, we can run `cargo build` to compile the project. 

```bash
$ cargo build
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.04s
```

Yay! It compiled successfully, which means the linking was successful. We can run the binary with `cargo run` to see the output.

```bash
$ cargo run
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.00s
     Running `target/debug/learning-linkers`
Global: 20
```

The output is `Global: 20`, which means the `foo` and `bar` functions were called successfully and the `Global` variable was modified by both functions (`Global` was original set to 5).
     

References:

- [High Level Compiler Architecture - Rustc Guide](https://rustc-dev-guide.rust-lang.org/overview.html)
- https://blog.mozilla.org/nnethercote/2019/10/10/visualizing-rust-compilation/
- https://medium.com/@squanderingtime/manually-linking-rust-binaries-to-support-out-of-tree-llvm-passes-8776b1d037a4
- https://man7.org/linux/man-pages/man1/nm.1.html
