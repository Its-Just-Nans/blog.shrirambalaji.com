---
title: Resolving Rust Symbols
description: This article is about my understanding of Rust linking, detailing learnings along the way about Linking in Unix systems, how Rust linkage differs from C, trying different linkers like mold, lld and understanding what they offer.
publishDate: May 15 2024
tags:
  - rust
  - linking
  - systems
draft: true

---
export let isDarkMode = null;

import { Picture, Image } from 'astro:assets';
import LightImage from './attachments/compiler-build-symbols-resolve-linker.svg';
import DarkImage from './attachments/compiler-build-symbols-resolve-linker-dark.svg';

Goals
- Basics of Linking in Unix systems
- Ld basics (mention mold)
- Rust compilation viz, linking static vs dynamic
- Demo
- Dive deeper
- Part II follow up for Windows

# Understanding Linking

"Programmers tend to build their programs on top of libraries of reusable code — for example, libc, which we talked about earlier. When turning your source code into an executable binary, a program called a linker resolves all these references by finding the library code and copying it into the binary. This process is called _static linking_, which means external code is included directly in the file that’s distributed."

A simple analogy for a Linker:
> Executable Linkers are basically just home theater setups - Chris Kanich

What are Symbols?

Symbols are how we go from variable names -> memory addresses in machine instructions. 

<Picture alt="Compiler Build Symbols Resolved by Linker" src={isDarkMode ? DarkImage: LightImage}>
  <source srcSet={DarkImage} media="(prefers-color-scheme: dark)" alt="Compiler Build Symbols Resolved by Linker"/>
  <source srcSet={LightImage} media="(prefers-color-scheme: light)" alt="Compiler Build Symbols Resolved by Linker"/>
  {/* <img src={LightImage} alt="Compiler Build Symbols Resolved by Linker" /> */}
</Picture>

In compiled language like C, C++, or Rust, a build consists of two phases. In the first phase, a compiler compiles source files into object files (`.o` files). In the second phase, a linker takes all object files and combines them into a single executable or shared library file.

## Linking in Linux systems

Let's setup a simple rust project in a Ubuntu Virtual Machine, and try to understand linking with it. I'm using [orbstack](https://docs.orbstack.dev/architecture#:~:text=OrbStack%20uses%20a%20lightweight%20Linux,integration%20with%20macOS%2C%20and%20more.) to create a "machine" on macOS which work like traditional vms, but shares the same kernel. 

After setting up rust in the vm using [rustup](https://rustup.rs), we use cargo to create a new rust project.

```bash
$ cargo new learning-linkers
```

Let's try to build it.

```shell
$ cd learning-linkers && cargo build
Compiling learning-linkers v0.1.0 (/Users/shrirambalaji/Repositories/learning-linkers)
error: linker `cc` not found
  |
  = note: No such file or directory (os error 2)
```

Hmm, an error. We run into a ```linker `cc` not found error``` because the rust installer assumes that a C linker is already installed, instead of checking for the necessary compiler toolchain. 

On linux machines, the de-facto toolchain is `gcc`(GNU Compiler Collection) which seems to be missing. The `build-essential` meta package has `gcc` and a couple other packages. Let's install that!

```shell
$ sudo apt install build-essential
```

We can also choose a different linker like [`lld`](https://lld.llvm.org)which is LLVM's linker or [mold](https://github.com/rui314/mold). [LLVM](https://llvm.org)is another compiler toolchain like gcc, but aims to be modular. Mold is a more recent alternative and is several times quicker based on their benchmarks.

##  Rust Compilation and the  `.o` object file

It's a systems language, so obviously our expectation is to be similar to C - right? Just let me compile, and give me an object file that I can link to later? That's called [dynamic linking](https://en.wikipedia.org/wiki/Dynamic_linker) and that's the default of how things work with C, C++.

Rust prefers the opposite called [static linking](https://en.wikipedia.org/wiki/Static_library) wherein it will link in all Rust and native dependencies, producing a single distributable binary as described above. 

> A [_crate_](https://doc.rust-lang.org/reference/crates-and-source-files.html) is a unit of compilation and linking, as well as versioning, distribution, and runtime loading. A crate contains a _tree_ of nested [module](https://doc.rust-lang.org/reference/items/modules.html) scopes. 

In Rust,  called a `bin` crate in rust, and is the default type of crate we get when we initialize a new project with `cargo`

### But, what happens if we try to get a single `.o` file in a `bin` crate?

Why does rust prefer this approach, and I think there are a couple of reasons for it:

-  `rustc` (invoked internally by `cargo`) compiles rust source code into an executable or a library (`.rlib`), rather than separately compiling to an object file and then linking them ie. it tries to do both the phases (compilation and linking) we discussed earlier in one step.
- `rustc` views a crate as the basic unit of compilation, not  files. hence, it typically compiles an entire crate at once.

But that doesn't mean that there are no `.o` files when compiling a `bin` crate, they are present in `/target/debug/incremental/*` directories. If you guessed it already, yes - rust supports incremental compilation ie. it compiles parts of a crate / project that have changed since the previous build. But these are typically managed by `rustc` and `cargo` internally.

Let's say we want to emit just an`object` file similar to what happens when we compile a `C` program.

```bash
$ rustc --emit=obj main.rs
```

This tells `rustc` to emit an object file (`main.o`) from the source file `main.rs`. The default `main.rs` source code just has a `main` function which prints out "Hello, World!"

```rust
fn main() {
    println!("Hello, world!");
}
```

But, there's a catch - the raw .o file doesn't have enough information that `rustc` needs to generate stubs / shims and invoke the linker. Moreover, the arguments we pass onto the linkers are crate-specific, and that information is missing in the object files. 

So back to square one - by default in the `bin` crate or with just a single file, the generated `.o` object files are not  useful.

## 


References:
- https://blog.mozilla.org/nnethercote/2019/10/10/visualizing-rust-compilation/
- https://medium.com/@squanderingtime/manually-linking-rust-binaries-to-support-out-of-tree-llvm-passes-8776b1d037a4